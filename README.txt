sdi1700076
ΜΑΝΤΖΟΥΡΑΝΗΣ ΓΙΩΡΓΟΣ

/* Για πολύ μικρά νούμερα στις παραμέτρους όπως 1 1 10 τρώει έρρορ ο validator. Για τιμές από 5 για hashtables και 25 gia bucket είναι οκ. Δεν κάνω κάποιον έλεγχο όταν δεσμεύω το πόσα
Records χωράει το Bucket. Ίσως γι αυτό. */ 

Η main συνάρτηση βρίσκεται στο diseaseMonitor.cpp.
Αρχικά γίνεται ο έλεγχος για τα arguments που εισάγει ο χρήστης. Έπειτα δημιουργώ δυναμικά ένα δέντρο για τα id's, ένα avl δέντρο που κρατάει
την πληροφορία των ασθενών και μέσω του οποίου δημιουργώ μια ταξινομημένη λίστα με βάση το entry date, 2 hash tables, 2 λίστες με όλες τις χώρες/ασθένειες,
2 hash tables που κρατάνε συγκεκριμένη πληροφορία για τα topk ερωτήματα.
Αρχικά εξετάζω αν υπάρχει το id του ασθενή. Αν δεν υπάρχει, σταματάει το πρόγραμμα, αλλιώς εισάγω τον ασθενή στο avl δέντρο των ασθενών και μέσω αυτού και 
με την χρήση pointer σε ασθενή διατηρώ μια διπλή λίστα ταξινομημένη. Την παραπάνω διαδικασία επιτυγχάνω κρατώντας πάντα τον τελευταίο κόμβο που μπήκε στον δέντρο,
και στη συνέχεια πέρνοντας τον πατέρα αυτού βρίσκω που υπάρχει η πληροφορία του πατέρα στην λίστα και ανάλογα με το αν ο κόμβος μπήκε δεξιά/αριστερά τον βάζω
πριν ή μετά από τον πατέρα στην λίστα. Στην περίπτωση που είναι duplicate απλά τον βάζω μετά από τον κόμβο που ήδη υπάρχει στην λίστα.
Στη συνέχεια hasharw τα disease/country του patient, και προσθέτω την εγγραφή μέσα στο hash table. Εάν η εγγραφή υπάρχει ήδη τότε θα έχει ήδη δημιουργηθεί ένα
avl δέντρο που θα κρατάει τις ημερομηνίες του συγκεκριμένου disease/country. Κάθε κόμβος του δέντρου δείχνει και σε έναν κόμβο της λίστα μέσω δείκτη, οπότε κάθε φορά
περνάω στην addRecord() και τον κόμβο που μπήκε στην λίστα πιο πρόσφατα. Στον κόμβο του δέντρου επίσης κρατάω και έναν ακέραιο για το ύψος καθώς και έναν δείκτη που συνδέει
τον κόμβο που μπαίνει με τον πατέρα του για να μπορώ να κρατάω την λίστα μου ταξινομημένη σε γρήγορο χρόνο.
Ύστερα προσθέτω, αν δεν υπάρχουν ήδη, τα disease/country σε μια λίστα και τέλος δημιουργώ τα 2 hash table όπου κρατάνε μια δομή Item, όπου Item είναι ένα struct που περιέχει
δείκτη σε char και έναν ακέραιο για να ξέρω για κάθε ασθένεια ποιες χώρες και πόσα κρούσματα έχουν και για κάθε χώρα ποιες και πόσες ασθένεις υπάρχουν. 
Τέλος καλείται η user_inpt() στην οποία και περνάω όλες μου τις δομές , τις οποίες και χρειάζομαι για να απαντήσω στα ερωτήματα.

! Πρωτού προχωρήσω στην επεξήγηση των ερωτημάτων να αναφέρω ότι σε κάθε ερώτηματα χρησιμοποιώ έναν ακέραιο count, με τον οποίο μετράω τις λέξεις που δίνονται κάθε φορά από τον χρήστη.
Αν ο αριθμός είναι αυτός που θέλω και αφού η πρώτη λέξη είναι κάθε φορά η ζητούμενη εντολή τότε προχοράω, αλλιώς εμφανίζω μηνύματα λάθους. !

Δομές:
/* Hash Tables */
Hash  : 1 για τις ασθένειες και 1 για τους ιούς. Έχει έναν ακέραιο για το μέγεθός του και έναν διπλό δείκτη στην κλάσση Bucket.
Bucket : Κρατάω το μέγεθός του και τον αριθμό εγγραφών. Επίσης έχω έναν δείκτη σε Bucket που δείχνει στο επόμενο Bucket και έναν διπλό δείκτη σε Record.
Record: Έναν δείκτη σε char που αναπαριστά τη χώρα κάθε φορά και έναν δείκτη σε AVL δέντρο.

helping_hash : Παρόμοια υλποίηση με αυτή της δομής του Hash, απλά κάθε Record εδώ ονομάζεται bucketEntry και έχει μια συμβολοσειρά και έναν δείκτη σε λίστα.
Η λίστα τώρα είναι generic για όλα τα δεδομέν, αλλά στη συγκεκριμένη περίπτωση δέχεται Item*, όπου κάθε Item αποτελείται από μια συμβολοσειρά που δηλώνει το όνομα της χώρας/ιού κάθε φορά
και έναν ακέραιο που μετράει στην ουσία το πλήθος των κρουσμάτων για την χώρα/ιό.

/* AVL */
AVL: Έχω έναν δείκτη σε treeNode που αποτελεί την ρίζα μου και μέσω της insert() η οποία καλέι την insertNode(), με την τελευταία να καλείται αναδρομικά, χτίζω το avl δέντρο μου. Στην insertNode(),
καλούνται κάθε φορά οι fixHeight() και selfBalance(), με την τελυταία να πραγματοποιεί όποια rotations χρειάζονται ανάλογα με το balancefactor,το οποίο και βρίσκω κάθε φορά με τη βοήθεια της μεταβλητής height
που είναι αποθυκευμένη στον κόμβο treeNode.
treeNode : Είναι ο κόμβος του avl δέντρου μου, στον οποίο κρατάω και την πληροφορία του πατέρα, διότι με διευκολύνει στα αρχικά insert μου, όπου χειρίζομαι την λίστα των ασθενών , με την βοήθεια του οποίου 
την κρατάω ταξινομημένη. Επίσης κρατάω έναν δείκτη σε κόμβο της λίστας των ασθενών - μόνο για την πρώτη εμφάνιση της πρώτης ημερομηνίας εισαγωγής -. Επίσης έχω ένα δείκτη σε date, όπου είναι και το κλειδί του δέντρου.

avl : Η δομή αυτή είναι παρόμοια με αυτή του AVL, με τη διαφορά ότι κρατάω μόνο τα id's και την χρησιμοποιώ μόνο για να ελέγχω αν υπάρχει το id κάθε φορα του ασθενή που θέλω να αποθηκεύσω στις δομές μου.

/* λίστα ασθενών */
list : Η δήλωσή της βρίσκεται στο Patient.h . Έχω έναν δείκτη σε head και έναν σε tail για πιο γρήγορες εισαγωγές στο τέλος. Δεν έχω να αναφέρω κάτι σημαντικό.
Ερωτήματα :

1.Έχω υλοποιήσει 2 printDiseasStats() στην δομή του hashtable με διαφορετικά ορίσματα η κάθε μια για να γίνονται overload. Για κάθε ασθένεια( την οποία και κρατάω σε μια λίστα, για να γλυτώνω παραπάνω επαναλήψεις στο hash ) ,
εμφανίζω τον αριθμό κρουσμάτων μέσα στα όρια που δίνονται ή και γενικότερα αν δεν δοθούν. Το παραπάνω επιτυγχάνεται μέσω συναρτήσεων που έχω υλοποιήσει για το avl, όπου και για το δέντρο κάθε ασθένειας,
μετράω όλους τους κόμβους αναδρομικά και ανάλογα με το τι ζητείται επιστρέφεται ένας ακέραιος. Υπάρχει επίσης η περίπτωση όπου κάποιοι κόμβοι μπορεί να έχουν duplicate τιμές, οπότε για κάθε κόμβο βλέπω σε ποιον κόμβο της λίστας
δείχνει, και διατρέχω τη λίστα μέχρι να βρω έναν κόμβο διαφορετικού date.

2.Έχω υλοποιήσει 2 diseaseFrequency() οι οποίες γίνονται overload. Για την ασθένεια virus, ψάχνω σε κάθε Bucket και με την συνάρτηση strinExist() βρίσκω σε ποια θέση του Bucket υπάρχει ο ιός. Αν δεν υπάρχει επιστρέφω -1 
και η διαδικασία αυτή επαναλαμβάνεται όσο υπάρχουν nextBucket. Η διαδικασία παραμένει η ίδια αν δοθεί και κάποιο country, με τη διαφορά ότι τώρα για κάθε κόμβο του δέντρου του συγκεριμένου disease, βλέπω στην λίστα των ασθενών
εάν το country είναι το ίδιο.

3 και 4. Έχω υλοποιήσει 2 διαφορετικές συναρτήσεις για αυτά τα 2 ερωτήματα. 
Όπως ανέφερα και στην αρχή έχω δημιουργήσει 2 ακόμα Hash tables που στην ουσία για κάθε χώρα κρατάνε μια λίστα από Items, όπου κάθε Item αποτελείται από έναν ακέραιο και από έναν δείκτη σε char.
Σας δίνω ένα σχήμα για να εξηγήσω καλύτερα ότι δεν μπορώ να γράψω.

Μια λίστα για κάθε χώρα με όλες τις ασθένειες που έχει και τα κρούσματά τους.
Greece : h1n1 : 2 -> covid :3 -> sars : 2 ->flu : 5 

Μια λίστα για κάθε ασθένεια με όλες τις χώρες που έχει εμφανιστεί και των αριθμό κρουσμάτων.
h1n1 : Greece : 2-> Russia : 3 -> Egypt :2 

Με την βοήθεια των παραπάνω hash tables απαντάω πολύ γρήγορα στα top-k χωρίς να δίνονται ημερομηνίες, γιατί βρίσκω απευθείας σε ποιο bucket βρίσκεται η χώρα και στη συνέχεια για τη χώρα αν μια ασθένεια υπάρχει
ήδη απλά αυξάνω τον ακέραιο, αλλίως προσθέτω την χώρα στο τέλος της λίστας.
Στη συνέχεια καλείται η top_k() για το hash table, όπου και δημιουργώ ένα max_heap με τη βοήθεια μια δομής queue, την οποία και έχω υλοποιήσει με διπλό δείκτη σε heap_node.( κόμβος του heap)
Ο κάθε κόμβος του heap έιναι στην ουσία κόμβος δέντρου όπου κρατάω και τον πατέρα για όποια swap χρειάζομαι στη συνέχεια. Επίσης κρατάω και έναν δείκτη σε Item, όπου είναι και το Key στον max_heap.
Κατά την εισαγωγή στον max_heap, έχω μια queue στην οποία βάζω κάθε φορά έναν heap_node και βγάζω έναν heap_node, μόνο αν έχουν δημιουργηθεί και τα 2 του παιδιά. Η ακόλουθη διαδικασία έχει παρόμοια λογική με αυτήν του
levelorder traversal, γι αυτό και χρησιμοποιώ την ουρά.
Τώρα όσον αφορά την εκτύπωση των topk, έχω μια επανάληψη που τρέχει από 0 έως k , κάνω pop() την ρίζα του max_heap και στην συνέχεια heapifyDown(). Η heapifyDown(), εκτελείται αναδρομικά και αυτό που κάνει είναι να συγρίνει κάθε 
φορά τον κόμβο πατέρα με τα παιδιά του, και όποιο από τα 2 είναι μεγαλύτερα , αν ο πατέρας έχει μικρότερη τιμή από το μεγαλύτερο παιδί του ,τότε γίνεται swap(μόνο οι δείκτες σε Item) και κατεβαίνω προς τα κάτω μέχρι να πετύχω NULL, 
η μέχρι να μην χρειάζεται άλλο swap.

Αν δίνονται ημερομηνιες, από την άλλη, δεν κάνω χρήση αυτής της δομής, αλλά με την βοήθεια των αρχικών λιστών όπου κρατάω τις χώρες/ιούς, για κάθε χώρα και για κάθε ιό, καλώ την diseasesFrequency() -με ή χωρίς τα dates -, 
η οποία μου επιστρέφει κάθε φορά κάποιους ακέραιους. Για τους ακέραιους αυτούς και για τα ανάλογα string, δημιουργώ μια λίστα από Items, την οποία και περνάω την topK() συνάρτηση μαζί με το K. Στο σημείο αυτό,
ακολουθώ την ίδια διαδικασία για την δημιουργία του max_heap.

5.Κάνω ό,τι ακριβώς έκανα και στην main, προσθέτοντας την εγγραφή σε όλες τις δομές μου αν δεν υπάρχει το record id ήδη. 
Η δημιουργία της εγγραφής γίνεται με την βοήθεια της createPatient(), η οποία δημιουργεί και επιστρέφει έναν ασθενή αν όλα τα δεδομένα είναι σωστά, αλλιώς επιστρέφει NULL.
Ο έλεγχος για τις ημερομηνίες γίνεται με την βοήθεια των συναρτήσεων validDate() οι οποίες και γίνονται overload.

6. Γίνεται αναζήτηση στο δέντρο των id, και αν υπάρχει προχωράω στο δέντρο των ασθενών με το οποίο διατηρώ την λίστα μου. Πηγαίνω στον κόμβο της λίστα με το συγκεκριμένο id
και κάνω Update το exit date.

7.Έχω υλοποιήσει 2 printNumCurrentPatients(), τις οποίες κάνω overload. Σε αυτήν χωρίς το όρισμα disease, πηγαίνω σε κάθε bucket( ακολουθώ όλη την λίστα των buckets) και για κάθε εγγραφή ( για κάθε disease ),
με την βοήθεια της λίστας των ασθενών βλέπω ποιοι είναι αυτοί με exitDate = '-', και επιστρέφω έναν ακέραιο.
Αν δοθεί παράμετρος disease, βλέπω αν υπάρχει το disease στο συγκεκριμένο bucket, αν υπάρχει βρίσκω τη θέση της εγγραφής και ακολουθώ την παραπάνω διαδικασία με την λίστα. Ομοίως για όλα τα buckets της λίστας.




